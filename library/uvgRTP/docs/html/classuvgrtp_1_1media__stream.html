<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvgRTP: uvgrtp::media_stream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">uvgRTP<span id="projectnumber">&#160;2.3.0</span>
   </div>
   <div id="projectbrief">An open-source library for RTP/SRTP media delivery</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>uvgrtp</b></li><li class="navelem"><a class="el" href="classuvgrtp_1_1media__stream.html">media_stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classuvgrtp_1_1media__stream-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">uvgrtp::media_stream Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classuvgrtp_1_1media__stream.html" title="The media_stream is an entity which represents one RTP stream.">media_stream</a> is an entity which represents one RTP stream.  
 <a href="classuvgrtp_1_1media__stream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="media__stream_8hh_source.html">media_stream.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0950a91bd645cbf842d8218ae4171aed"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a0950a91bd645cbf842d8218ae4171aed">add_srtp_ctx</a> (uint8_t *key, uint8_t *salt)</td></tr>
<tr class="memdesc:a0950a91bd645cbf842d8218ae4171aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add keying information for user-managed SRTP session.  <br /></td></tr>
<tr class="separator:a0950a91bd645cbf842d8218ae4171aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157e9973d92b65e82914d4028690c770"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a157e9973d92b65e82914d4028690c770">push_frame</a> (uint8_t *data, size_t data_len, int rtp_flags)</td></tr>
<tr class="memdesc:a157e9973d92b65e82914d4028690c770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to remote participant with a custom timestamp.  <br /></td></tr>
<tr class="separator:a157e9973d92b65e82914d4028690c770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068a0963e06f789b4e4310a45cbe4409"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a068a0963e06f789b4e4310a45cbe4409">push_frame</a> (std::unique_ptr&lt; uint8_t[]&gt; data, size_t data_len, int rtp_flags)</td></tr>
<tr class="memdesc:a068a0963e06f789b4e4310a45cbe4409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to remote participant with a custom timestamp.  <br /></td></tr>
<tr class="separator:a068a0963e06f789b4e4310a45cbe4409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cb1cf34b639c9ba71b047b3ba26d22"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#ac0cb1cf34b639c9ba71b047b3ba26d22">push_frame</a> (uint8_t *data, size_t data_len, uint32_t ts, int rtp_flags)</td></tr>
<tr class="memdesc:ac0cb1cf34b639c9ba71b047b3ba26d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to remote participant with a custom timestamp.  <br /></td></tr>
<tr class="separator:ac0cb1cf34b639c9ba71b047b3ba26d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5577c57f1bdd5b888aa4e8c4f939eba7"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a5577c57f1bdd5b888aa4e8c4f939eba7">push_frame</a> (uint8_t *data, size_t data_len, uint32_t ts, uint64_t ntp_ts, int rtp_flags)</td></tr>
<tr class="memdesc:a5577c57f1bdd5b888aa4e8c4f939eba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to remote participant with custom RTP and NTP timestamps.  <br /></td></tr>
<tr class="separator:a5577c57f1bdd5b888aa4e8c4f939eba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9099254c6bf16f255f5f50441ec9d2"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#abe9099254c6bf16f255f5f50441ec9d2">push_frame</a> (std::unique_ptr&lt; uint8_t[]&gt; data, size_t data_len, uint32_t ts, int rtp_flags)</td></tr>
<tr class="memdesc:abe9099254c6bf16f255f5f50441ec9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to remote participant with a custom timestamp.  <br /></td></tr>
<tr class="separator:abe9099254c6bf16f255f5f50441ec9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d2a209b2647d0f3ee7948e8cf45438"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a56d2a209b2647d0f3ee7948e8cf45438">push_frame</a> (std::unique_ptr&lt; uint8_t[]&gt; data, size_t data_len, uint32_t ts, uint64_t ntp_ts, int rtp_flags)</td></tr>
<tr class="memdesc:a56d2a209b2647d0f3ee7948e8cf45438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to remote participant with custom RTP and NTP timestamps.  <br /></td></tr>
<tr class="separator:a56d2a209b2647d0f3ee7948e8cf45438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c854a4c36572f91008a8e1e49e38bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structuvgrtp_1_1frame_1_1rtp__frame.html">uvgrtp::frame::rtp_frame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#ab0c854a4c36572f91008a8e1e49e38bb">pull_frame</a> ()</td></tr>
<tr class="memdesc:ab0c854a4c36572f91008a8e1e49e38bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll a frame indefinitely from the media stream object.  <br /></td></tr>
<tr class="separator:ab0c854a4c36572f91008a8e1e49e38bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466067ad9924a52530c62c53c1b397b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structuvgrtp_1_1frame_1_1rtp__frame.html">uvgrtp::frame::rtp_frame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a466067ad9924a52530c62c53c1b397b4">pull_frame</a> (size_t timeout_ms)</td></tr>
<tr class="memdesc:a466067ad9924a52530c62c53c1b397b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll a frame for a specified time from the media stream object.  <br /></td></tr>
<tr class="separator:a466067ad9924a52530c62c53c1b397b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a558b23866976e52c5903996544a27"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a74a558b23866976e52c5903996544a27">install_receive_hook</a> (void *arg, void(*hook)(void *, <a class="el" href="structuvgrtp_1_1frame_1_1rtp__frame.html">uvgrtp::frame::rtp_frame</a> *))</td></tr>
<tr class="memdesc:a74a558b23866976e52c5903996544a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous way of getting frames.  <br /></td></tr>
<tr class="separator:a74a558b23866976e52c5903996544a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cee4fe3bf423ec317b4a3eacc136238"><td class="memItemLeft" align="right" valign="top">rtp_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a2cee4fe3bf423ec317b4a3eacc136238">configure_ctx</a> (int rcc_flag, ssize_t value)</td></tr>
<tr class="memdesc:a2cee4fe3bf423ec317b4a3eacc136238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the media stream, see <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587f" title="RTP context configuration flags.">RTP_CTX_CONFIGURATION_FLAGS</a> for more details.  <br /></td></tr>
<tr class="separator:a2cee4fe3bf423ec317b4a3eacc136238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab339f15d5a852beacd901b7b78e887ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuvgrtp_1_1rtcp.html">uvgrtp::rtcp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#ab339f15d5a852beacd901b7b78e887ea">get_rtcp</a> ()</td></tr>
<tr class="memdesc:ab339f15d5a852beacd901b7b78e887ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the RTCP object of the media stream.  <br /></td></tr>
<tr class="separator:ab339f15d5a852beacd901b7b78e887ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8796cb34e0e6c61af8cabd13dd6793b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvgrtp_1_1media__stream.html#a8796cb34e0e6c61af8cabd13dd6793b5">get_ssrc</a> () const</td></tr>
<tr class="memdesc:a8796cb34e0e6c61af8cabd13dd6793b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SSRC identifier. You can use the SSRC value for example to find the report block belonging to this <a class="el" href="classuvgrtp_1_1media__stream.html" title="The media_stream is an entity which represents one RTP stream.">media_stream</a> in RTCP sender/receiver report.  <br /></td></tr>
<tr class="separator:a8796cb34e0e6c61af8cabd13dd6793b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b543a64861d06fc74c87aa51d1dbe9"><td class="memItemLeft" align="right" valign="top"><a id="a13b543a64861d06fc74c87aa51d1dbe9" name="a13b543a64861d06fc74c87aa51d1dbe9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_ipv6</b> () const</td></tr>
<tr class="separator:a13b543a64861d06fc74c87aa51d1dbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classuvgrtp_1_1media__stream.html" title="The media_stream is an entity which represents one RTP stream.">media_stream</a> is an entity which represents one RTP stream. </p>
<p><a class="el" href="classuvgrtp_1_1media__stream.html" title="The media_stream is an entity which represents one RTP stream.">media_stream</a> is defined by the ports which are used for sending and/or receiving media. It is possible for <a class="el" href="classuvgrtp_1_1media__stream.html" title="The media_stream is an entity which represents one RTP stream.">media_stream</a> to be bi- or unidirectional. The unidirectionality is achieved by specifying RCE_SEND_ONLY or RCE_RECEIVE_ONLY flag when creating <a class="el" href="classuvgrtp_1_1media__stream.html" title="The media_stream is an entity which represents one RTP stream.">media_stream</a>.</p>
<p>If RCE_RTCP was given when creating <a class="el" href="classuvgrtp_1_1media__stream.html" title="The media_stream is an entity which represents one RTP stream.">media_stream</a>, you can get the <a class="el" href="classuvgrtp_1_1rtcp.html" title="RTCP instance handles all incoming and outgoing RTCP traffic, including report generation.">uvgrtp::rtcp</a> object with <a class="el" href="classuvgrtp_1_1media__stream.html#ab339f15d5a852beacd901b7b78e887ea" title="Get pointer to the RTCP object of the media stream.">get_rtcp()</a>-function.</p>
<p><a class="el" href="classuvgrtp_1_1media__stream.html" title="The media_stream is an entity which represents one RTP stream.">media_stream</a> corresponds to one RTP session in <a href="https://www.rfc-editor.org/rfc/rfc3550">RFC 3550</a>. </p>

<p class="definition">Definition at line <a class="el" href="media__stream_8hh_source.html#l00050">50</a> of file <a class="el" href="media__stream_8hh_source.html">media_stream.hh</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0950a91bd645cbf842d8218ae4171aed" name="a0950a91bd645cbf842d8218ae4171aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0950a91bd645cbf842d8218ae4171aed">&#9670;&#160;</a></span>add_srtp_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::add_srtp_ctx </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>salt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add keying information for user-managed SRTP session. </p>
<p>For user-managed SRTP session (flag RCE_SRTP_KMNGMNT_USER), the media stream is not started until SRTP key has been added and all calls to <a class="el" href="classuvgrtp_1_1media__stream.html#a157e9973d92b65e82914d4028690c770" title="Send data to remote participant with a custom timestamp.">push_frame()</a> will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>SRTP master key, default is 128-bit long </td></tr>
    <tr><td class="paramname">salt</td><td>112-bit long salt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If key or salt is invalid </td></tr>
    <tr><td class="paramname">RTP_NOT_SUPPORTED</td><td>If user-managed SRTP was not specified in create_stream() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cee4fe3bf423ec317b4a3eacc136238" name="a2cee4fe3bf423ec317b4a3eacc136238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cee4fe3bf423ec317b4a3eacc136238">&#9670;&#160;</a></span>configure_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::configure_ctx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rcc_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the media stream, see <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587f" title="RTP context configuration flags.">RTP_CTX_CONFIGURATION_FLAGS</a> for more details. </p>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If the provided value is not valid for a given configuration flag </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If setsockopt(2) failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab339f15d5a852beacd901b7b78e887ea" name="ab339f15d5a852beacd901b7b78e887ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab339f15d5a852beacd901b7b78e887ea">&#9670;&#160;</a></span>get_rtcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuvgrtp_1_1rtcp.html">uvgrtp::rtcp</a> * uvgrtp::media_stream::get_rtcp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to the RTCP object of the media stream. </p>
<p>This object is used to control all RTCP-related functionality and RTCP documentation can be found from <a class="el" href="classuvgrtp_1_1rtcp.html">uvgrtp::rtcp</a></p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to RTCP object</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uvgrtp::rtcp*</td><td>If RTCP has been enabled (RCE_RTCP has been given to <a class="el" href="classuvgrtp_1_1session.html#a0b9fb48e95cbfdb76fd9f61e8cafe8e4" title="Create a uni- or bidirectional media stream.">uvgrtp::session::create_stream()</a>) </td></tr>
    <tr><td class="paramname">nullptr</td><td>If RTCP has not been enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8796cb34e0e6c61af8cabd13dd6793b5" name="a8796cb34e0e6c61af8cabd13dd6793b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8796cb34e0e6c61af8cabd13dd6793b5">&#9670;&#160;</a></span>get_ssrc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t uvgrtp::media_stream::get_ssrc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SSRC identifier. You can use the SSRC value for example to find the report block belonging to this <a class="el" href="classuvgrtp_1_1media__stream.html" title="The media_stream is an entity which represents one RTP stream.">media_stream</a> in RTCP sender/receiver report. </p>
<dl class="section return"><dt>Returns</dt><dd>SSRC value </dd></dl>

</div>
</div>
<a id="a74a558b23866976e52c5903996544a27" name="a74a558b23866976e52c5903996544a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a558b23866976e52c5903996544a27">&#9670;&#160;</a></span>install_receive_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::install_receive_hook </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, <a class="el" href="structuvgrtp_1_1frame_1_1rtp__frame.html">uvgrtp::frame::rtp_frame</a> *)&#160;</td>
          <td class="paramname"><em>hook</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous way of getting frames. </p>
<p>Receive hook is an alternative to polling frames using <a class="el" href="classuvgrtp_1_1media__stream.html#ab0c854a4c36572f91008a8e1e49e38bb" title="Poll a frame indefinitely from the media stream object.">uvgrtp::media_stream::pull_frame()</a>. Instead of application asking from uvgRTP if there are any new frames available, uvgRTP will notify the application when a frame has been received</p>
<p>The hook should not be used for media processing as it will block the receiver from reading more frames. Instead, it should only be used as an interface between uvgRTP and the calling application where the frame hand-off happens.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Optional argument that is passed to the hook when it is called, can be set to nullptr </td></tr>
    <tr><td class="paramname">hook</td><td>Function pointer to the receive hook that uvgRTP should call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If hook is nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0c854a4c36572f91008a8e1e49e38bb" name="ab0c854a4c36572f91008a8e1e49e38bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c854a4c36572f91008a8e1e49e38bb">&#9670;&#160;</a></span>pull_frame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuvgrtp_1_1frame_1_1rtp__frame.html">uvgrtp::frame::rtp_frame</a> * uvgrtp::media_stream::pull_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll a frame indefinitely from the media stream object. </p>
<dl class="section return"><dt>Returns</dt><dd>RTP frame</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uvgrtp::frame::rtp_frame*</td><td>On success </td></tr>
    <tr><td class="paramname">nullptr</td><td>If an unrecoverable error happened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a466067ad9924a52530c62c53c1b397b4" name="a466067ad9924a52530c62c53c1b397b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466067ad9924a52530c62c53c1b397b4">&#9670;&#160;</a></span>pull_frame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuvgrtp_1_1frame_1_1rtp__frame.html">uvgrtp::frame::rtp_frame</a> * uvgrtp::media_stream::pull_frame </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll a frame for a specified time from the media stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>How long is a frame waited, in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP frame</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uvgrtp::frame::rtp_frame*</td><td>On success </td></tr>
    <tr><td class="paramname">nullptr</td><td>If a frame was not received within the specified time limit or in case of an error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a068a0963e06f789b4e4310a45cbe4409" name="a068a0963e06f789b4e4310a45cbe4409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068a0963e06f789b4e4310a45cbe4409">&#9670;&#160;</a></span>push_frame() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::push_frame </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; uint8_t[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtp_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to remote participant with a custom timestamp. </p>
<p>If so specified either by the selected media format and/or given <a class="el" href="util_8hh.html#a15b2d6364db6065a482c99827f4bd2af" title="RTP context enable flags.">RTP_CTX_ENABLE_FLAGS</a>, uvgRTP fragments the input data into RTP packets of 1492 bytes, or to any other size defined by the application using <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587fa7667fb72b42a2c11991b4879619f9f83">RCC_MTU_SIZE</a></p>
<p>The frame is automatically reconstructed by the receiver if all fragments have been received successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Smart pointer to data the that should be sent </td></tr>
    <tr><td class="paramname">data_len</td><td>Length of data </td></tr>
    <tr><td class="paramname">rtp_flags</td><td>Optional flags, see <a class="el" href="util_8hh.html#af03a75996471fc531742cd640c7caf2d" title="These flags are given to uvgrtp::media_stream::push_frame() and they can be OR&#39;ed together.">RTP_FLAGS</a> for more details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If one of the parameters are invalid </td></tr>
    <tr><td class="paramname">RTP_MEMORY_ERROR</td><td>If the data chunk is too large to be processed </td></tr>
    <tr><td class="paramname">RTP_SEND_ERROR</td><td>If uvgRTP failed to send the data to remote </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If an unspecified error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe9099254c6bf16f255f5f50441ec9d2" name="abe9099254c6bf16f255f5f50441ec9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9099254c6bf16f255f5f50441ec9d2">&#9670;&#160;</a></span>push_frame() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::push_frame </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; uint8_t[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtp_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to remote participant with a custom timestamp. </p>
<p>If so specified either by the selected media format and/or given <a class="el" href="util_8hh.html#a15b2d6364db6065a482c99827f4bd2af" title="RTP context enable flags.">RTP_CTX_ENABLE_FLAGS</a>, uvgRTP fragments the input data into RTP packets of 1492 bytes, or to any other size defined by the application using <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587fa7667fb72b42a2c11991b4879619f9f83">RCC_MTU_SIZE</a></p>
<p>The frame is automatically reconstructed by the receiver if all fragments have been received successfully.</p>
<p>If application so wishes, it may override uvgRTP's own timestamp calculations and provide timestamping information for the stream itself. This requires that the application provides a sensible value for the ts parameter. If RTCP has been enabled, <a class="el" href="classuvgrtp_1_1rtcp.html#a5d0d06f9b4b7779d96d8d60938627316" title="Provide timestamping information for RTCP.">uvgrtp::rtcp::set_ts_info()</a> should have been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Smart pointer to data the that should be sent </td></tr>
    <tr><td class="paramname">data_len</td><td>Length of data </td></tr>
    <tr><td class="paramname">ts</td><td>32-bit timestamp value for the data </td></tr>
    <tr><td class="paramname">rtp_flags</td><td>Optional flags, see <a class="el" href="util_8hh.html#af03a75996471fc531742cd640c7caf2d" title="These flags are given to uvgrtp::media_stream::push_frame() and they can be OR&#39;ed together.">RTP_FLAGS</a> for more details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If one of the parameters are invalid </td></tr>
    <tr><td class="paramname">RTP_MEMORY_ERROR</td><td>If the data chunk is too large to be processed </td></tr>
    <tr><td class="paramname">RTP_SEND_ERROR</td><td>If uvgRTP failed to send the data to remote </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If an unspecified error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56d2a209b2647d0f3ee7948e8cf45438" name="a56d2a209b2647d0f3ee7948e8cf45438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d2a209b2647d0f3ee7948e8cf45438">&#9670;&#160;</a></span>push_frame() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::push_frame </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; uint8_t[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ntp_ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtp_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to remote participant with custom RTP and NTP timestamps. </p>
<p>If so specified either by the selected media format and/or given <a class="el" href="util_8hh.html#a15b2d6364db6065a482c99827f4bd2af" title="RTP context enable flags.">RTP_CTX_ENABLE_FLAGS</a>, uvgRTP fragments the input data into RTP packets of 1492 bytes, or to any other size defined by the application using <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587fa7667fb72b42a2c11991b4879619f9f83">RCC_MTU_SIZE</a></p>
<p>The frame is automatically reconstructed by the receiver if all fragments have been received successfully.</p>
<p>If application so wishes, it may override uvgRTP's own timestamp calculations and provide timestamping information for the stream itself. This requires that the application provides a sensible value for the ts parameter. If RTCP has been enabled, <a class="el" href="classuvgrtp_1_1rtcp.html#a5d0d06f9b4b7779d96d8d60938627316" title="Provide timestamping information for RTCP.">uvgrtp::rtcp::set_ts_info()</a> should have been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Smart pointer to data the that should be sent </td></tr>
    <tr><td class="paramname">data_len</td><td>Length of data </td></tr>
    <tr><td class="paramname">ts</td><td>32-bit RTP timestamp for the packet </td></tr>
    <tr><td class="paramname">ntp_ts</td><td>64-bit NTP timestamp value of when the packets data was sampled. NTP timestamp is a 64-bit unsigned fixed-point number with the integer part (seconds) in the first 32 bits and the fractional part (fractional seconds) in the last 32 bits. Used for synchronizing multiple streams. </td></tr>
    <tr><td class="paramname">rtp_flags</td><td>Optional flags, see <a class="el" href="util_8hh.html#af03a75996471fc531742cd640c7caf2d" title="These flags are given to uvgrtp::media_stream::push_frame() and they can be OR&#39;ed together.">RTP_FLAGS</a> for more details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If one of the parameters are invalid </td></tr>
    <tr><td class="paramname">RTP_MEMORY_ERROR</td><td>If the data chunk is too large to be processed </td></tr>
    <tr><td class="paramname">RTP_SEND_ERROR</td><td>If uvgRTP failed to send the data to remote </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If an unspecified error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a157e9973d92b65e82914d4028690c770" name="a157e9973d92b65e82914d4028690c770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157e9973d92b65e82914d4028690c770">&#9670;&#160;</a></span>push_frame() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::push_frame </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtp_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to remote participant with a custom timestamp. </p>
<p>If so specified either by the selected media format and/or given <a class="el" href="util_8hh.html#a15b2d6364db6065a482c99827f4bd2af" title="RTP context enable flags.">RTP_CTX_ENABLE_FLAGS</a>, uvgRTP fragments the input data into RTP packets of 1492 bytes, or to any other size defined by the application using <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587fa7667fb72b42a2c11991b4879619f9f83">RCC_MTU_SIZE</a></p>
<p>The frame is automatically reconstructed by the receiver if all fragments have been received successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to data the that should be sent, uvgRTP does not take ownership of the memory </td></tr>
    <tr><td class="paramname">data_len</td><td>Length of data </td></tr>
    <tr><td class="paramname">rtp_flags</td><td>Optional flags, see <a class="el" href="util_8hh.html#af03a75996471fc531742cd640c7caf2d" title="These flags are given to uvgrtp::media_stream::push_frame() and they can be OR&#39;ed together.">RTP_FLAGS</a> for more details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If one of the parameters are invalid </td></tr>
    <tr><td class="paramname">RTP_MEMORY_ERROR</td><td>If the data chunk is too large to be processed </td></tr>
    <tr><td class="paramname">RTP_SEND_ERROR</td><td>If uvgRTP failed to send the data to remote </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If an unspecified error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0cb1cf34b639c9ba71b047b3ba26d22" name="ac0cb1cf34b639c9ba71b047b3ba26d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cb1cf34b639c9ba71b047b3ba26d22">&#9670;&#160;</a></span>push_frame() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::push_frame </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtp_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to remote participant with a custom timestamp. </p>
<p>If so specified either by the selected media format and/or given <a class="el" href="util_8hh.html#a15b2d6364db6065a482c99827f4bd2af" title="RTP context enable flags.">RTP_CTX_ENABLE_FLAGS</a>, uvgRTP fragments the input data into RTP packets of 1492 bytes, or to any other size defined by the application using <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587fa7667fb72b42a2c11991b4879619f9f83">RCC_MTU_SIZE</a></p>
<p>The frame is automatically reconstructed by the receiver if all fragments have been received successfully.</p>
<p>If application so wishes, it may override uvgRTP's own timestamp calculations and provide timestamping information for the stream itself. This requires that the application provides a sensible value for the ts parameter. If RTCP has been enabled, <a class="el" href="classuvgrtp_1_1rtcp.html#a5d0d06f9b4b7779d96d8d60938627316" title="Provide timestamping information for RTCP.">uvgrtp::rtcp::set_ts_info()</a> should have been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to data the that should be sent, uvgRTP does not take ownership of the memory </td></tr>
    <tr><td class="paramname">data_len</td><td>Length of data </td></tr>
    <tr><td class="paramname">ts</td><td>32-bit timestamp value for the data </td></tr>
    <tr><td class="paramname">rtp_flags</td><td>Optional flags, see <a class="el" href="util_8hh.html#af03a75996471fc531742cd640c7caf2d" title="These flags are given to uvgrtp::media_stream::push_frame() and they can be OR&#39;ed together.">RTP_FLAGS</a> for more details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If one of the parameters are invalid </td></tr>
    <tr><td class="paramname">RTP_MEMORY_ERROR</td><td>If the data chunk is too large to be processed </td></tr>
    <tr><td class="paramname">RTP_SEND_ERROR</td><td>If uvgRTP failed to send the data to remote </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If an unspecified error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5577c57f1bdd5b888aa4e8c4f939eba7" name="a5577c57f1bdd5b888aa4e8c4f939eba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5577c57f1bdd5b888aa4e8c4f939eba7">&#9670;&#160;</a></span>push_frame() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtp_error_t uvgrtp::media_stream::push_frame </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ntp_ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rtp_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to remote participant with custom RTP and NTP timestamps. </p>
<p>If so specified either by the selected media format and/or given <a class="el" href="util_8hh.html#a15b2d6364db6065a482c99827f4bd2af" title="RTP context enable flags.">RTP_CTX_ENABLE_FLAGS</a>, uvgRTP fragments the input data into RTP packets of 1492 bytes, or to any other size defined by the application using <a class="el" href="util_8hh.html#aa98d9238629e33567e73af0d239e587fa7667fb72b42a2c11991b4879619f9f83">RCC_MTU_SIZE</a></p>
<p>The frame is automatically reconstructed by the receiver if all fragments have been received successfully.</p>
<p>If application so wishes, it may override uvgRTP's own timestamp calculations and provide timestamping information for the stream itself. This requires that the application provides a sensible value for the ts parameter. If RTCP has been enabled, <a class="el" href="classuvgrtp_1_1rtcp.html#a5d0d06f9b4b7779d96d8d60938627316" title="Provide timestamping information for RTCP.">uvgrtp::rtcp::set_ts_info()</a> should have been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to data the that should be sent, uvgRTP does not take ownership of the memory </td></tr>
    <tr><td class="paramname">data_len</td><td>Length of data </td></tr>
    <tr><td class="paramname">ts</td><td>32-bit RTP timestamp for the packet </td></tr>
    <tr><td class="paramname">ntp_ts</td><td>64-bit NTP timestamp value of when the packets data was sampled. NTP timestamp is a 64-bit unsigned fixed-point number with the integer part (seconds) in the first 32 bits and the fractional part (fractional seconds) in the last 32 bits. Used for synchronizing multiple streams. </td></tr>
    <tr><td class="paramname">rtp_flags</td><td>Optional flags, see <a class="el" href="util_8hh.html#af03a75996471fc531742cd640c7caf2d" title="These flags are given to uvgrtp::media_stream::push_frame() and they can be OR&#39;ed together.">RTP_FLAGS</a> for more details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTP error code</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RTP_OK</td><td>On success </td></tr>
    <tr><td class="paramname">RTP_INVALID_VALUE</td><td>If one of the parameters are invalid </td></tr>
    <tr><td class="paramname">RTP_MEMORY_ERROR</td><td>If the data chunk is too large to be processed </td></tr>
    <tr><td class="paramname">RTP_SEND_ERROR</td><td>If uvgRTP failed to send the data to remote </td></tr>
    <tr><td class="paramname">RTP_GENERIC_ERROR</td><td>If an unspecified error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="media__stream_8hh_source.html">media_stream.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
